
object {
	
	case class Branch(val scores: Seq[Int], val deck: Seq[Int], val parentDeck: Seq[Int])
}

class BlackJackHand extends Actor {

	def receive ={
		case Branch => 
			val scores = Branch.scores
			val deck = Branch.deck
			val pDeck = Branch.parentDeck
			
			if(17 <= scores.sum) {
				val score = scores.sum
				val ratio = hitRatioByLength(scores.length, pDeck.length)
				sender() ! Seq((score,ratio))
			}
			else if(scores.contains(1)){
				val changedAce = changeAceToEleven(scores.count(_ == 1), scores)
				changedAce match {
				          case Some(x) =>
				          	val score = x.sum
				          	val ratio = hitRatioByLength(x.length -1,parentDeck.length)
				          	Seq((score,ratio))
				          case None =>
				          	for {
				          		t <- deck
				          	} yield self ! Branch(sores :+ t, deck.diff(Seq(t)), pDeck)
				}
			}
			else for {
					t <- deck
				} yield self ! Branch(sores :+ t, deck.diff(Seq(t)), pDeck)
			}
	}
}

//
//  /*
//  name    calculateAllHands
//  func    17を超えるまで引く時、ディーラが辿る可能性のある全ての手札を取得し、その総和と引く確率のタプルのリストを返却
//  args    hands: Int        確認したディーラの手札
//          deck: Seq[Int]    現在の山札
//  return  Seq[(Int,Float)]
//          Int               引く可能性がある手札の総和
//          Float             その確率
//   */
//  def calculateAllHandsHitInRange(hands: Int, parentDeck: Seq[Int]): Seq[(Int,Float)] = {
//
//    /*
//    name    isInRange
//    func    1を含む手札の総和を受取り、その総和に10を足した数値が17～21に含まれていればtrueを返却
//    args    hand: Int   1が含まれている手札の総和
//    return  Boolean     1を11にした方が良い場合にtrueを返却
//     */
//    val isInRange: Int => Boolean = (hand: Int) => (17 to 21).contains(hand)
//
//    /*
//    name    changeAceToEleven
//    func    1を11にした方が良い場合は受取ったリストの末尾に10を加えて返却、1のままの方が良い場合は何も返さない
//    args    aceCount: Int       1が含まれている数
//            hands: Seq[Int]     1が含まれている手札
//    return  Option[Seq[Int]]    1を11に変えた手札の総和
//     */
//    @tailrec
//    def changeAceToEleven(aceCount: Int, hands: Seq[Int]): Option[Seq[Int]] = {
//      //aceCountが0の場合は変えない方が良いのでNoneを返却
//      if (aceCount < 1) None
//      //17<=x<=21の場合は変えた方が良いので、変えた分を加算リストを返却
//      else if (isInRange(hands.sum + 10 * aceCount)) Some(hands :+ 10 * aceCount)
//      //17<=x<=21に含まれていない場合は変える数を減らしてもう一度調べる
//      else changeAceToEleven(aceCount -1, hands)
//    }
//
//    /*
//    name    getHandsOver17
//    func    手札を山札から引いていき、17以上の手札を返却する
//    args    hands: Seq[Int]     1があるか確認する必要がある為、手札をリストで受取る
//            deck: Seq[Int]      山札
//    return  Seq[(Int,Float)]
//            Int                 引く可能性がある手札の総和
//            Float               その確率
//     */
//    def getHandsOver17(hands: Seq[Int], deck: Seq[Int]): Seq[(Int,Float)] = {
//
//      //受取った手札が17以上の場合はその総和とその手札を引く確率を返却
//      if(17 <= hands.sum) {
//        val score = hands.sum
//        val ratio = hitRatioByLength(hands.length,parentDeck.length)
//        Seq((score,ratio))
//      }
//      //手札に1が含まれていた場合
//      else if(hands.contains(1)){
//        //1を11に変えた方が良い場合は変えた方が良い数だけ末尾に10を足したリストを取得
//        val changedAce = changeAceToEleven(hands.count(_ == 1), hands)
//        changedAce match {
//          //変えた方が良い場合はその総和を返却
//          case Some(x) =>
//            val score = x.sum
//            //changeAceでリストの末尾に、必要分だけ10を掛けた値を足しているので長さを1減らす
//            val ratio = hitRatioByLength(x.length -1,parentDeck.length)
//            Seq((score,ratio))
//          //変えない方が良い場合は再帰
//          case None =>
//            for {
//              //山札の全てのカードを取得
//              t <- deck
//            }
//        }
//      }
//      //1が含まれておらず、17よりも低い場合
//      else for {
//        //山札の全てのカードを取得
//        t <- deck
//        f <- {
//          val f = Future(getHandsOver17(hands :+ t, deck.diff(Seq(t))))
//          Await.result(f, Duration.Inf)
//        }
//      } yield f
//    }
//
//    //再帰関数の開始
//    getHandsOver17(Seq(hands), parentDeck)
//  }